; SICP 2.3.3 例: 集合を表現する/順序つきリストとしての集合
;集合演算を速くする方法のひとつとして、集合の要素が昇順に並ぶように表現を変えるというものがあります。
;これをするためには、二つのオブジェクトを比較してどちらが大きいか判断するための何らかの方法が必要です。
;例えば、記号を辞書順に比較したり、オブジェクトに一意の数値を割り振ることに決めて対応する数値によって要素を比較したりといったことが考えられます。
;ここでは話を簡単にするため、集合の要素が数値である場合についてのみ考えることにします。
;この場合、要素は > と < によって比較できます。数値の集合を表現するのには、要素を昇順に並べたものを使います。
;上に挙げた最初の表現では、{1, 3, 6, 10} という集合を表すのに要素をどのように並べてもかまいま
;せんでしたが、新しい表現では (1 3 6 10) というリストしか許可しません。
;---
;順序に従って並べることのひとつの利点は element-of-set? で出てきます。
;項目があるかどうかを調べるのに、もう集合全体を走査する必要はありません。
;探している項目よりも大きい要素に出会ったら、その項目が集合内にないということがわかります。
(define (element-of-set? x set)
  (cond ((null? set) false)
         ((= x (car set)) true)
         ((< x (car set)) false)
         (else (element-of-set? x (cdr set)))))
;これはどれだけのステップ数の節約になるでしょうか。
;平均的には、集合の約半分の項目を検査しなければいけないということになるでしょう。
;このため、必要な平均ステップ数はだいたい n/2 になります。
;これは依然として Θ(n) という増加オーダーですが、それでもやはり、
;平均的には、前の実装に比べてステップ数を半分に節約できます。
;---
;intersection-set では、さらに目覚ましい高速化が達成できます。
;順序なし表現では、この演算には Θ(n^2 ) というステップ数が必要でした。
;それは、set1 の要素それぞれに対して set2 の完全な走査を行っていたからでした。
;しかし、順序つきの表現では、より賢い方法が使えます。
;まず、二つの集合の最初の要素 x1 と x2 を比較します。
;もし x1 と x2 が等しければ、それは共通部分の要素になり、
;共通部分の残りは二つの集合の cdr の共通部分ということになります。
;では、x1 が x2 より小さい場合はどうなるか考えてみましょう。
;x2 はset2 の最小要素なので、x1 は set2 のどこにも現れないと結論づけることができます。
;つまり、共通部分にも含まれないということになります。
;このため共通部分は、set2 と、set1 の cdr との共通部分に等しくなります。
;同じように、もし x2 が x1 よりも小さければ、求める共通部分は、set1 と、set2 の cdr との共通部分となります。
(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2)) '()
     (let ((x1 (car set1)) (x2 (car set2)))
       (cond ((= x1 x2) (cons x1 (intersection-set (cdr set1) (cdr set2))))
              ((< x1 x2) (intersection-set (cdr set1) set2))
              ((< x2 x1) (intersection-set set1 (cdr set2)))))))
;このプロセスで必要となるステップ数を見積もるには、各ステップで、共通部分問題をより小さな集合の共通部分集合の
;計算に縮小していることに注意してください。
;縮小は、set1 と set2 のどちらかまたは両方から最初の要素を削除することによって行われます。
;このため、必要なステップ数は、最大でも set1と set2 の大きさの合計で、順序なし表現のように大きさの積に
;なることはありません。これは、 Θ(n 2 ) というオーダーに対して Θ(n) というオーダーになる
;ということで、そこそこの大きさの集合に対してもかなりの高速化になります。