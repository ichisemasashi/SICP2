; SICP 2.3.3 add3 例: 集合を表現する/集合と情報検索

;ここまで、集合をリストで表現するのにどのような方法があるかを検討し、データオブジェクトに対してどのような表現を
;選ぶかということが、そのデータを使うプログラムのパフォーマンスに大きな影響を及ぼすということを見てきました。
;集合に対して詳しく検討するもうひとつの理由は、ここで考察するテクニックは情報検索に関わる応用の中でよく出てくる
;ものだということです。

;個別のレコードを大量に含むデータベースについて考えてみましょう。例えば、企業の人事ファイルや、会計システムの取引
;などです。データ管理システムは普通、そのレコードにアクセスしたり更新したりするのに多くの時間を消費するので、
;レコードにアクセスする効率的な手法が必要となります。これは、各レコードの中で、識別キー (key) として使える部分を
;特定することによって行うことができます。キーは、レコードを一意に識別するものであれば何でもかまいません。
;人事ファイルであれば、従業員番号などがよいでしょう。会計システムであれば、取引番号になるかもしれません。
;キーが何であっても、レコードをデータ構造として定義する際には、あるレコードに対して関連づけられたキーを取得する
; key セレクタ手続きを持つ必要があります。

;ここで、データベースをレコードの集合として表現することにします。あるキーに対するレコードの場所を調べるには、
; lookup という手続きを使います。この手続きは、キーとデータベースを引数に取り、そのキーを持つレコードを返すか、
;そのようなレコードがなければ偽を返します。lookup は、element-of-set? とほぼ同じように実装されます。
;例えば、レコードの集合が順序なしリストとして表現されていれば、次のようにできます。

(define (lookup given-key set-of-records)
  (cond ((null? set-of-records) false)
        ((equal? given-key (key (car set-of-records)))
         (car set-of-records))
        (else (lookup given-key (cdr set-of-records)))))

;もちろん、巨大な集合を表現するのには、順序なしリストよりもいい方法があります。レコードを “ランダムアクセス” する
;必要がある情報検索システムでは、普通は木構造による手法によって表現されます。例えば、前に検討した二分木のような
;ものです。そのようなシステムを設計するにあたっては、データ抽象化の方法論はとても役に立ちます。設計する人は、
;順序なしリストのような単純で素直な表現を使って、最初の実装を作ることができます。これは最終的なシステムのためには
;不適切なものでしょうが、システムの残りの部分をテストするための “quick and dirty”(手早く汚い) データベースを
;提供してくれるという意味では役に立ちます。データ表現を修正してより洗練されたものにすることは後になってからでも
;できます。もしデータベースが抽象セレクタとコンストラクタによってアクセスされるようになっていれば、そうやって表現を
;変更しても、システムの残りの部分には修正の必要がないはずです。