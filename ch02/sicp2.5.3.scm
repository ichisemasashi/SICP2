;; SICP 2.5.3 例: 記号代数

;;記号代数式の操作は複雑な処理です。それについて検討することで、大規模システムの設計の際に起こる
;;多くの困難な問題について知ることができます。
;;代数式は一般に、木構造の演算子を被演算子に適用する階層構造と見なすことができます。
;;代数式を構築するには、定数や変数のような基本オブジェクトから始めて、
;;それらを加算や乗算のような代数演算子によって組み合わせます。
;;ほかの言語の場合と同じように、複合オブジェクトを簡単に参照できるように抽象化を行います。
;;記号代数での典型的な抽象化としては、線形結合、多項式、有理関数、三角関数などの考え方があります。
;;これらは複合 “型” と見なすことができ、そうすることで式の処理を指示することがやりやすくなります。
;;例えば、次の式は、
;; $$ x^2 \sin (y^2 + 1) + x \cos 2y + \cos (y^3 - 2y^2) $$
;;整数を係数とする y の多項式の三角関数を係数とする x の多項式として記述することができます。

;;ここでは完全な代数処理システムを開発しようとしているわけではありません。
;;そのようなシステムは、深い代数の知識と洗練されたアルゴリズムを具現化した、
;;非常に複雑なプログラムになります。
;;ここでは、代数操作の単純でありながら重要な部分である多項式の算術演算について見ていきます。
;;また、そのようなシステムを設計する際にどのような決定をしなければいけないかということと、
;;その取り組みに抽象データとジェネリック演算という考え方を適用する方法について説明します。

;;;;;;;;;;
;; 多項式の算術演算

;;多項式の数値演算を行うシステムを設計するにあたっての最初の仕事は、多項式とは何なのかを決めることです。
;;多項式は通常、いくつかの変数 (多項式の不 定元 (indeterminate)) に関して定義されます。
;;簡単にするために、ここではひとつしか不定元を持たない多項式 (一元多項式 (univariate polynomial)) に
;;限定することにします。多項式は項の和として定義し、その項は係数か、不定元の冪乗か、
;;係数と不定元の冪乗の積であるとします。係数は、多項式の不定元と独立な代数式と定義します。
;;例えば、
;; $$ 5x^2 + 3x + 7 $$
;;は単純な x の多項式で、
;; $$ (y^2 + 1)x^3 + (2y)x + 1 $$
;;は係数が y の多項式である x の多項式です。
;;ここまでで、もういくつかの厄介な問題を避けて通ってきています。上の一番目の多項式は、
;;多項式 5y2 + 3y + 7 と同じものでしょうか、それとも異なるものでしょうか。
;;妥当な答えは、“多項式を純粋に数学の関数であると考えれば、同じものである。
;;しかし、多項式を構文形式であると考えれば、異なるものである” となるでしょう。
;;また、二番目の多項式は、x の多項式を係数とする y の多項式と代数学的に等価です。
;;私たちのシステムはこのことを認識するべきでしょうか。
;;しかも、多項式を表現する方法はほかにもあります—例えば、因数の積、(一元多項式の場合) 根の集合、
;;特定の点の集合における多項式の値のリストなどによって表すこともできます.
;;この代数操作システムでは、“多項式” というのは特定の構文形式であって、
;;その奥にある数学的意味ではないと決めることで、これらの問題を解決できます。
;;次に、多項式の算術演算をどのようなものにするか考える必要があります。
;;この単純なシステムでは、加算と乗算だけ考えることにします。さらに、組み合わせる二つの多項式は
;;同じ不定元を持っていなければならないということにします。

;;このシステムの設計にあたっては、おなじみのデータ抽象化の規律に従います。
;;多項式はpoly というデータ構造を使って表現し、poly はひとつの変数と項の集まりからなります。
;;poly からそれらの部品を抽出するセレクタ variable, term-list と、
;;与えられた変数と項のリストから poly を組み立てるコンストラクタ make-poly があると想定します。
;;変数はただの記号なので、変数の比較には 2.3.2 節の same-variable? 手続きが使えます。
;;以下の手続きは、poly の加算と乗算を定義するものです。

(define (add-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (add-terms (term-list p1) (term-list p2)))
      (error "Polys not in same var: ADD-POLY" (list p1 p2))))

(define (mul-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (mul-terms (term-list p1) (term-list p2)))
      (error "Polys not in same var: MUL-POLY" (list p1 p2))))

;;多項式を私たちのジェネリック算術演算システムに組み入れるためには、タイプタグをつける必要があります。
;;タグとしては polynomial を使うことにして、タグつき多項式に対する適切な演算を演算テーブルに組み込みます。
;;2.5.1 節同様、コードはすべて多項式パッケージの組み込み手続きの中に埋め込むことにします。

(define (install-polynomial-package)
  ;; 内部手続き
  ;;poly の表現
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  (define (same-variable? v1 v2) ;; from sicp2.3.2.rkt
    (and (variable? v1)
         (variable? v2)
         (eq? v1 v2)))
  (define (variable? x) ;; from sicp2.3.2.rkt
    (symbol? x))
  ;;項と項リストの表現
  ⟨下記の adjoin-term . . . coeff 手続き⟩
  (define (add-poly p1 p2) ...)
  ⟨add-poly が使う手続き⟩
  (define (mul-poly p1 p2) ...)
  ⟨mul-poly が使う手続き⟩
  ;; システムのほかの部分とのインターフェイス
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  'done)

;;多項式の加算は項ごとに実行します。同じ次数の項 (つまり、同じ指数を持つ不定元) 同士を
;;組み合わせる必要があります。これは、足す項と足される項の係数の合計を係数とする、
;;同じ次数を持つ新しい項を作ることで行えます。
;;片方にだけ項があって、もう一方のほうに同じ次数の項がない場合は、
;;構築中の和の多項式にその項をそのまま追加します。

;;項リストを操作するために、空の項リストを返す the-empty-termlist というコンストラクタと、
;;項リストに新しい項を追加するadjoin-termというコンストラクタがあると想定します。
;;さらに、与えられた項リストが空かどうか調べる empty-termlist? という述語と、
;;項リストから最大次数の項を取り出すセレクタ first-term、
;;最大次数の項以外の全ての項を返すセレクタ rest-terms もあると想定します。
;;項を操作するために、与えられた次数と係数から項を構築するコンストラクタ make-term と、
;;項の次数と係数をそれぞれ返すセレクタ order と coeff があると想定します。
;;これらの演算によって、項と項リストがデータ抽象として捉えられるようになり、
;;具体的な表現は別に考えることができます。

;;以下は、二つの多項式の和となる項リストを構築する手続きです。

(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1))
               (t2 (first-term L2)))
           (cond ((< (order t2) (order t1))
                  (adjoin-term
                   t1 (add-terms (rest-terms L1) L2)))
                 ((< (order t1) (order t2))
                  (adjoin-term
                   t2 (add-terms L1 (rest-terms L2))))
                 (else
                  (adjoin-term
                   (make-term (order t1)
                              (add (coeff t1) (coeff t2)))
                   (add-terms (rest-terms L1)
                              (rest-terms L2)))))))))

;;ここでの最も重要なポイントは、項の係数同士を足し合わせるのにジェネリック加算手続き add を
;;使っているというところです。以下で見ていくように、このことは強力な結果をもたらします。

;;二つの項リストを乗算するには、まず与えられた項と与えられた項リストのすべての項と乗算する
;;mul-term-by-all-terms を繰り返し使って、最初のリストの各項をもう一方のリストのすべての項と乗算します。
;;次に、返される項リストの列 (一つ目のリストの項それぞれに対してひとつずつ) を和として集積します。
;;二つの項の乗算では、各乗数の次数の和を次数とし、各乗数の係数の積を係数とする項を作ります。

