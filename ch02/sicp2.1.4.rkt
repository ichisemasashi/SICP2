; SICP 2.1.4 発展問題: 区間演算
; 精度のわかっている不正確な量(例えば物理装置の測定値) を扱う
;そのような近似値を使って計算を行った場合、結果が精度つきの数値となるようにしたい
;二つの抵抗 R1, R2 の並列に等価な抵抗値 Rpを次の式によって計算する
; Rp = 1/{1/R1 + 1/R2}

; 抵抗値は普通、抵抗の製造者によって保証された何らかの許容誤差の範囲内であることしかわかりません。
;例えば、“10% の許容誤差で 6.8Ω” というラベルのついた抵抗を買うと、その抵抗の抵抗値は
;6.8 − 0.68 = 6.12Ω から 6.8 + 0.68 = 7.48Ω の間であるということしか確かには言えません。
;そのため、6.8Ω 10% の抵抗と 4.7Ω 5% の抵抗を並列に接続すると、
;その組み合わせの抵抗は約 2.58Ω(二つの抵抗が下限値である場合) から約 2.97Ω(二つの抵抗が上限
;値である場合) までの範囲になります。
;“区間”(不正確な量の取りうる値の範囲を表すオブジェクト) を組み合わせる数値演算のセットとして “区間演算” を実装する

;下限と上限という二つの端点を持つ “区間” という抽象オブジェクト
;区間の両端点が与えられれば、データコンストラクタ make-interval を使って区間を構築できる

;二つの区間を足す手続き: 和が取りうる最小値は二つの下限の和であり、最大値は二つの上限の和
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                    (+ (upper-bound x) (upper-bound y))))

;両端点の積の最小値と最大値を求め、それらを答えとなる区間の下限と上限とすることによって、
;二つの区間の積を計算
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
         (p2 (* (lower-bound x) (upper-bound y)))
         (p3 (* (upper-bound x) (lower-bound y)))
         (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                      (max p1 p2 p3 p4))))

;二つの区間の割り算は、一つ目に二つ目の逆数をかけることにします。
;区間の逆数の下限と上限は、上限の逆数と下限の逆数という順番になることに気をつけてください。
(define (div-interval x y)
  (mul-interval x (make-interval (/ 1.0 (upper-bound y))
                                       (/ 1.0 (lower-bound y)))))
