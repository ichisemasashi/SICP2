; SICP 2.1.2 抽象化の壁(abstraction barrier)
; 有理数システムの構造
;----- 有理数を使うプログラム -----
;   問題ドメインでの有理数
;----- add-rat sub-rat ... -----
;   分母と分子としての有理数
;----- make-rat numer denom -----
;   ペアとしての有理数
;----- cons car cdr -----
;   ペアの実装(何でもよい)
;実質的に、それぞれのレベルの手続きは、抽象化の壁を定義し、異なるレベルをつなぐインターフェイスとなっています。
;  -> プログラムを保守したり修正したりするのが簡単になる
;もし表現方法への依存がごく少数のプログラムモジュールに制限されるように設計されていなければ、
;大きなプログラムではこの作業は時間とコストがかかるものになるでしょう。
;例えば、有理数を既約に簡約する問題の別の解き方として、簡約を実行するタイミングを、
;有理数の構築時でなく、有理数の部品へのアクセス時にするというやり方があります。
;この場合、コンストラクタとセレクタは違ったものになります。
(load "util.rkt")
(define (make-rat n d)
  (cons n d))
(define (numer r)
  (let ((g (gcd (car r) (cdr r))))
    (/ (car r) g)))
(define (denom r)
  (let ((g (gcd (car r) (cdr r))))
    (/ (cdr r) g)))
; この実装と前の実装との違いは、いつ gcd を計算するかというところです。
;プログラムを普通に使う際に、同じ有理数の分子や分母に何回もアクセスするのであれば、
;gcd は有理数の構築時に計算したほうがいいでしょう。そうでなければ、gcd の計算は
;アクセス時まで遅らせたほうがいいかもしれません。どちらを選ぶにしても、
;実装を切り替える場合に、add-rat, sub-rat などはまったく修正する必要がありません。
;表現方法への依存を少しだけのインターフェイス手続きに限定することは、
;プログラムの修正時だけでなく、プログラムの設計時にも役に立ちます。
;別の実装を考慮するための柔軟性を維持できるからです。