;; SICP 2.4.3 add1 データ主導プログラミングと加法性 メッセージパッシング

;; データ主導プログラミングでポイントとなる考え方は、プログラム中のジェネリック演算を
;; 図 2.22のような演算-型テーブルによって明示的に扱うというところです。
;; 2.4.2 節で使ったプログラミングスタイルでは、それぞれの演算に自分のディスパッチの面倒を
;; 見させることによって、必要となる型ディスパッチ を構築していました。
;; 実質的には、それぞれのジェネリック演算手続きがテーブルの行を表すというやり方で、
;; 演算-型テーブルを行に分解していたことになります。

;; もうひとつの実装戦略は、テーブルを列に分解し、データ型によってディスパッチを行う “賢い演算” を使うのではなく、
;; 演算の名前によってディスパ ッチを行う “賢いデータオブジェクト” を使うというものです。
;; これを実現するには、データオブジェクト (例えば直交形式の複素数) を手続きとして表現し、
;; その手続きは実行するべき演算名を引数として取り、指定された演算を実行するというようにします。
;; このような規律に従うと、make-from-real-imag は以下のように書くことができます。
(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y)
          ((eq? op 'magnitude) (sqrt (+ square x) (square y)))
          ((eq? op 'angle) (atan y x))
          (else (error "Unknown op: MAKE-FROM-REAL-IMAG" op))))
  dispatch)

;; apply-generic 手続きはジェネリック演算を引数に適用するものでしたが、
;; このデータに対応する apply-generic 手続きは、単に演算の名前を
;; データオブジ ェクトに渡して、オブジェクトに仕事をさせるだけになります。
(define (apply-generic op arg)
  (arg op))
;; make-from-real-imag の返す値が手続き—内部手続き dispatch—であることに注意してください。
;; これは、apply-generic が演算の実行を要求したときに 呼び出される手続きです。

;;このプログラミングスタイルはメッセージパッシング (message passing) と呼ばれています。
;;この名前は、データオブジェクトは要求された演算の名前を “メッセージ” として受け取る実体であるというイメージから来ています。
;;メ ッセージパッシングの例については、2.1.3 節ですでに見ています。そこでは、 cons, car, cdr が
;;データオブジェクトを使わずに手続きだけを使って定義でき るということを見てきました。
;;ここでは、メッセージパッシングがただの数学的トリックではなく、
;;ジェネリック演算によってシステムを組み立てるうえでの便利な技術だということを示しました。
;;この章の残りでは、ジェネリックな 算術演算について検討するために、メッセージパッシングではなく
;;データ主導プログラミングを使い続けることにします。第 3 章ではメッセージパッシングに戻り、
;;それがシミュレーションプログラムを構築するうえでの強力なツール になるということを見ていきます。
