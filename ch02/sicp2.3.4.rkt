; SICP 2.3.4 例: ハフマン符号化木

;この節では、集合と木を操作するためのリスト構造とデータ抽象化の使い方を練習します。
;ここでは、データを 1 と 0 の列 (ビット列) として表現する手法を適用対象とします。
;例えば、コンピュータ内でテキストを表現するのに使われる ascii 標準符号は、各文字を 7 ビットの列として表現します。
;7 ビットを使うことで、2^7 、つまり 128 通りの異なる文字を区別できます。
;一般的に、n 個の異なる記号を区別しようと思うと、記号ごとに log2(n) ビットを使う必要があります。
;もしメッセージすべてが A, B, C, D, E, F, G, H という 8 個の記号からなるとすると、
;一文字あたり 3 ビットの符号を選ぶことができます。例えば、次のようになります。
;
;A 000
;B 001
;C 010
;D 011
;E 100
;F 101
;G 110
;H 111
;
;この符号を使って次のメッセージ BACADAEAFABBAAAGAH を符号化すると、54 ビットの列になります。
; 001000010000011000100000101000001001000000000110000111
;
;ascii 符号や、上に挙げた A から H までの符号は、メッセージ内のそれぞれの記号を同じビット数で表すので、
;固定⻑ (fixed-length) 符号と言います。しかし、時には異なる記号が異なるビット数で表されることもある
;可変⻑ (variable-length) 符号を使ったほうがいい場合もあります。
;例えばモールス符号では、アルファベットの各文字に対して使う短点と⻑点の数が異なります。特に、最も
;よく出てくる文字の E は、短点ひとつで表されます。
;一般的に、もしメッセージの中でとてもよく出てくる記号とほとんど出てこない記号があるのなら、よく出てくる記号に短い符号を
;割り当てるとデータをより効率的に (つまり、メッセージに対して少ないビット数で) 符号化できます。次に挙げる、A から H
;までに対する別のコードについて考えてみましょう。
;A 0
;B 100
;C 1010
;D 1011
;E 1100
;F 1101
;G 1110
;H 1111
;この符号を使って符号化すると、上と同じメッセージが次のようになります。
; 100010100101101100011010100100000111001111
;この列は 42 ビットなので、上に示した固定⻑符号に比べて空間を 20% 以上節約できていることになります。

;可変⻑符号を使ううえで難しいことのひとつに、0 と 1 の列を読んでいく際に、いつ記号の終わりに達したかを
;どうやって知るかということがあります。
;モールス符号では、各文字に対応する短点と⻑点の列の後に、特別な分離符号(separator code)(この場合は休止) を置くことで、
;この問題を解決しています。ほかの解決法として、どの記号についても、その符号全体がほかの記号に対する符号の前の部分
;(接頭辞 (prefix)) になることがないように符号を設計するというものがあります。そのような符号は接頭符号 (prefix code) と
;呼ばれます。上の例では、A を 0、B を 100 として符号化しているので、ほかのどの記号も、 0 や 100 で始まる符号を持つことは
;できません。

;一般的に、符号化するメッセージの相対頻度を利用した可変⻑接頭符号を使えば、かなりの節約ができます。
;これを行う戦略のひとつにハフマン符号化法というものがあります。これは発見者の David Huffman にちなんでつけら
;れた名前です。ハフマン符号は二分木として表現でき、葉は符号化対象の記号となります。
;木の中で、葉でないノードは、そのノード以下の葉に対応する記号をすべて含んだ集合を持っています。
;それに加えて、葉の記号それぞれには重み (相対頻度) が割り当てられていて、葉でないノードはその下にある葉の重
;みをすべて合計した重みをそれぞれ持っています。重みは符号化・復号化の際には使いません。
;以下では、木を構築する際に重みをどう利用するのか見ていきます。
;下に、上に書いた A から H までの符号に対するハフマン木を示しています。
;葉の重みは、A が相対頻度 8、B が相対頻度 3、ほかの文字は相対頻度 1
;で現れるようなメッセージに対してこの木が設計されているということを示しています。
;        {A B C D E F G H} 17
;                 o
;                / \
;               /   \ {B C D E F G H} 9
;             A 8    o                 
;                   / \
;                  /   \
;                 /     \
;                /       \ {E F G H} 4
;               /         o
;              /         / \
;   {B C D} 5 / {E F} 2 /   \  
;            o         o     \ 
;           / \       / \     \
;          /   \{C D}/   \     \ {G H} 2
;        B 3    o 2;E 1  F 1    o       
;              / \             / \      
;             /   \           /   \
;           C 1  D 1        G 1   H 1
;ハフマン木があれば、どの記号に対する符号も、根から始めてその記号を持つ葉にたどり着くまで下りていくことで知ることができます。
;左の枝を下りるたびに符号に 0 を追加し、右の枝を下りるたびに 1 を追加します
;(どちらの枝を下りるかについては、どちらの枝にその記号の葉があるか、またはその記号を集合に含むかを見て決めます)。
;例えば、図の根から始めて D の葉に着くまでには、右枝、左枝、右枝、右枝とたどっていきます。そのため、D に
;対する符号は 1011 となります。

;ハフマン木を使ってビット列を復号するには、根から始めて、左と右のどちらの枝を下りるのか
;をビット列の 0 と 1 の列を使って決めます。葉に着くたびに、メッセージ中の記号を新たにひとつ生成し、
;そこでまた根に戻って次の記号を探します。例えば、上記の木と 10001010 というビット列があるとします。
;根から始めて、右の枝を下り (ビット列の最初のビットは 1 なので)、それから左の枝を下り (二番目のビットは 0 なので)、
;次に左の枝を下ります (三番目のビットも 0 なので)。こうすると B の葉にたどり着くので、
;復号したメッセージの最初の記号は B です。ここでまた根から始めて、ビット列中の次のビットは 0 なので、左に動きます。
;こうすると、A の葉に着きます。それからまた根から始めると、残りのビット列は 1010 なので、右、左、右、左と動いて C に着きます。
;つまり、メッセージ全体は BAC ということになります。


;;;;;;;;;;;
; ハフマン木の生成
;記号の “アルファベット” と相対頻度がわかっているとき、“最善の” 符号を作るにはどうしたらいいでしょうか
;(言い換えると、メッセージを最小のビット数で符号化するのはどのような木でしょうか)。
;ハフマンはこれを行うアルゴリズムを与え、結果となる符号が実際に、符号構築時に使った頻度と記号の相
;対頻度が一致するようなメッセージを符号化するのに最適な可変⻑符号であるということを示しました。
;ここではハフマン符号の最適性の証明はせずに、ハフマン木の構築の仕方のみを示します。

;ハフマン木を生成するアルゴリズムはとても単純です。考え方としては、出現頻度が最低の記号が根から一番遠いところに
;出てくるように木を配置するというものです。まず、符号構築対象の初期データによって決まる、記号と頻度を持つ葉ノードの集合から
;始めます。ここで、重みが小さいほうから二つの葉を選び、二つをくっつけて新しいノードを作り、新しいノードの左と右の枝が
;その二つのノードになるようにします。新しいノードの重みは二つの重みの合計とします。元の集合からその二つの葉を取り除き、
;代わりに新しいノードを入れます。それからこのプロセスを続けていきます。各段階で、重みが小さいほうから二つのノードを集合から
;取り除き、それらを左と右の枝として持つノードを代わりに入れることよって、その二つのノードをくっつけていきます。
;ノードがひとつだけになったら、それが木全体の根となり、プロセスは停止します。
;以下に、図 2.18のハフマン木が生成される過程を示します。
; Initial leaves {(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)}
;          Merge {(A 8) (B 3) ({C D} 2) (E 1) (F 1) (G 1) (H 1)}
;          Merge {(A 8) (B 3) ({C D} 2) ({E F} 2) (G 1) (H 1)}
;          Merge {(A 8) (B 3) ({C D} 2) ({E F} 2) ({G H} 2)}
;          Merge {(A 8) (B 3) ({C D} 2) ({E F G H} 4)}
;          Merge {(A 8) ({B C D} 5) ({E F G H} 4)}
;          Merge {(A 8) ({B C D E F G H} 9)}
;    Final merge {{A B C D E F G H} 17)}
;このアルゴリズムは常に同じ木になるとは限りません。各ステップで、最小の重みとなるノードのペアが
;一意であるとは限らないからです。また、二つのノードをくっつける順番をどうするか
;(つまり、どちらを右枝としてどちらを左枝とするか) も任意です。

;;;;;;;;;;
; ハフマン木の表現

;以下の練習では、ハフマン木を使ってメッセージの暗号化・復号化を行ったり、上で概要を示したアルゴリズムに従って
;ハフマン木を作ったりするシステムを扱います。まず、木をどのように表現するかを検討しましょう。

;木の葉は、leaf という記号、その葉の記号、重みからなるリストによって表現します。

(define (make-leaf symbol weight)
  (list 'leaf symbol weight))
(define (leaf? object)
  (eq? (car object) 'leaf))
(define (symbol-leaf x)
  (cadr x))
(define (weight-leaf x)
  (caddr x))

;一般の木は、左枝、右枝、記号の集合、重みからなります。
;記号の集合は、単純に記号のリストにして、より複雑な集合の表現は使わないことにします。
;二つのノードをくっつけて木を作るとき、その木の重みは二つのノードの重みの合計となり、
;記号の集合は、二つのノードが持つ記号の集合の和集合となります。記号の集合はリストとして表されているため、
;和集合は2.2.1 節で定義した append 手続きによって作ることができます。
(load "util.rkt")
(define (make-code-tree left right)
  (list left right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))
;木をこうやって作ると、セレクタは次のようになります。
(define (left-branch tree)
  (car tree))
(define (right-branch tree)
  (cadr tree))
(define (symbols tree)
  (if (leaf? tree) (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree) (weight-leaf tree)
      (cadddr tree)))
;手続き symbols と weight は、渡されたものが葉である場合と一般の木である場合とで、少し違うことをしなければいけません。
;これらは、ジェネリック手続き (generic procedure)(二種類以上のデータを扱う手続き) の簡単な例になっています。
;これについては、2.4 節と2.5 節で詳しく説明します。


;;;;;;;;;;
; 復号化手続き

;以下の手続きは、復号化アルゴリズムを実装したものです。0 と 1 のリストに加え、ハフマン木を引数に取ります。
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits) '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch) (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit: CHOOSE-BRANCH" bit))))

