; SICP 2.3.3 add1 マップのネスト
;列というパラダイムを拡張して、普通はネストしたループによって表現されるような多くの計算に適用できます。
;“正の整数 n が与えられたとき、1 ≤ j < i ≤ n で、かつ i + j が素数となるような
;異なる正の整数 i と j のすべての順序つきペアを見つけよ。”
;例えば、n が 6のとき、ペアは以下のようになります。
; (i,j) -> i+j
; (2,1)->3, (3,2)->5, (4,1)->5, (4,3)->7, (5,2)->7, (6,1)->7, (6,5)->11
;この計算の自然な構築方法として、n 以下の正の整数からなる、大きい順に並んだすべてのペアの列を生成し、
;フィルタによって合計が素数となるペアを選択し、それからフィルタを通過したそれぞれの (i, j) のペアに
;対して (i, j, i + j)という三つ組を作るというものがあります。
; ペアの列を生成する方法としては、すべての整数 i ≤ n に対して整数 j < iを列挙し、
;そのような i と j すべてに対して (i, j) を生成するというものがあります。

;ここで、列の演算を使って、(enumerate-interval 1 n) という列にマップを行います。
;そして、この列のそれぞれの i に対して、 (enumerate-interval 1 (- i 1)) という列にマップを行います。
;この後者の列のそれぞれの j に対して、(list i j) というペアを生成します。
;これによって、それぞれの i に対するペアの列ができます。
;すべての i に対して、すべての列を (append で集積して) 組み合わせることで、求めるペアの列ができます。
(load "sicp2.2.3_2.38.rkt")

;(accumulate append nil
;           (map (lambda (i)
;               (map (lambda (j) (list i j))
;                   (enumerate-interval 1 (- i 1))))
;               (enumerate-interval 1 n)))
;マップと集積を append によって組み合わせることは、この種のプログラムではとてもよくあることですので、
;独立した手続きとして分離することにします。
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))

;このペアの列をフィルタして、和が素数となるものを探します。
;フィルタの述語は、列のそれぞれの要素に対して呼ばれます。
;述語の引数はペアで、述語はペアから整数を取り出す必要があります。
;そのため、列のそれぞれの要素に適用する述語は次のようになります。
(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))

;最後に、フィルタを通ったペアの列に対して次の手続きでマップして、結果の列を生成します。
;手続きは、ペアの二つの要素とその合計からなる三つ組を構築するものです。
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
;これらのステップすべてを組み合わせると
(define (prime-sum-pairs n)
  (map make-pair-sum
      (filter prime-sum?
             (flatmap (lambda (i)
                        (map (lambda (j) (list i j))
                            (enumerate-interval 1 (- i 1))))
                     (enumerate-interval 1 n)))))

;マップのネストは、区間の列挙以外の列に対しても役に立ちます。
;ある集合 Sに対して、そのすべての順列を生成したいとします。
;つまり、集合の項目を並べる方法をすべて生成するということになります。
;例えば、{1, 2, 3} の順列は、{1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, {3, 2, 1} です。
;集合 S の順列を生成するための計画として、S のすべての項目 x に対して、
;S − x の順列の列を生成し、それぞれの先頭に x を置くというやり方が使えます。
;こうすると、S の x それぞれに対して、x から始まる S の順列の列が得られます。
;すべての x に対するこれらの列を組み合わせると、S の順列すべてが得られます。
(define (permutations s)
  (if (null? s) (list nil)
     (flatmap (lambda (x)
                (map (lambda (p) (cons x p))
                    (permutations (remove x s))))
             s)))
(define (remove x seq)
  (filter (lambda (i) (not (= i x))) seq))
;この戦略によって、S の順列を求める問題を、S よりも要素数の少ない集合の順列を求める問題に縮約している
;最終的には、要素のない集合を表す空リストに到達します。
;この場合、(list nil) というひとつの項目からなる列、つまり空集合を生成します。