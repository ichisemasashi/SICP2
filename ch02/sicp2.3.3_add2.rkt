; SICP 2.3.3 例: 集合を表現する/二分木としての集合
;集合の要素を木という形式で配置することで、順序つきリスト表現をさらに改善できます。
;木の各ノードは集合の要素をひとつ持ち、それはノードの “エントリ” と呼ばれます。
;また、ほかの二つのノード (ノードは空であることもあります) へのリンクも持っています。
;“左” のリンクは、そのノードより小さな要素を指していて、“右” のリンクはそのノードより
;大きな要素を指しています。

;集合{1,3,5,7,9,11}を表現するさまざまな二分木
;       7           3              5
;      / \         / \            / \
;     3   9       1   7          3   9
;    / \   \         / \        /   / \ 
;   1   5   11      5   9      1   7   11                             
;                        \                                            
;                         11

;同じ集合を木という形で表現するのには、数多くの方法がありえます。
;ここで、有効な木の表現の条件として求めるものは、あるノードの左部分木のすべての要
;素がそのノードの要素よりも小さく、右部分木のすべての要素がそれよりも大きいということだけです。

;木による表現の利点は次の通りです。ある数値 x がある集合に含まれているかどうかをチェックしたいとします。
;まず、x とトップノードのエントリを比較します。もし x がそれより小さければ、左部分木だけを探索すればいい
;ということがわかります。もし x がそれより大きければ、右部分木だけを探索すればいいということです。
;ここで、もし木が “バランスが取れた” 状態であれば、各部分木の大きさは元の木の約半分です。
;そのため、一回のステップで、大きさ n の木を探索するという問題を、大きさ n/2 の木を探索するという問題
;に縮小したことになります。木の大きさは各ステップで半分になるので、大きさ n の木の探索に必要なステップ数は
;Θ(log n) で増加すると予測できます。
;大きな集合に対しては、これは以前の表現に比べてかなりの高速化になるでしょう。

;木はリストを使って表現できます。各ノードは、ノードのエントリ、左部分木、右部分木という三つの項目のリストになります。
;左または右の部分木が空リストである場合は、そこにつながる部分木がないということを示します。
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))

(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (entry set)) true)
        ((< x (entry set))
         (element-of-set? x (left-branch set)))
        ((< (entry set) x)
         (element-of-set? x (right-branch set)))))

;集合に項目を追加するというのも同じように実装でき、必要ステップ数はやはり Θ(log n) になります。
;項目 x を追加するには、x をノードのエントリと比較し、右と左のどちらの枝に追加するべきかを決めます。
;そして、x を適切な枝に追加したら、この新しく作った枝を元のエントリやほかの枝とくっつけ合わせます。
;もし x がエントリに等しければ、ノードをそのまま返します。もし空の木に x を追加するよう求められたら、
;エントリが x で、右と左の枝が空である木を生成します。
(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((< x (entry set))
         (make-tree (entry set)
                    (adjoin-set x (left-branch set))
                    (right-branch set)))
        ((< (entry set) x)
         (make-tree (entry set)
                    (left-branch set)
                    (adjoin-set x (right-branch set))))))

;木の探索が対数的ステップで実行できるという上の主張は、木が “バランスが取れている”という前提に依存しています。
;つまり、すべての木の左右の部分木はだいたい同じ数の要素を持っていて、各部分木は親の約半分の要素を持っているということです。
;しかし、ここで構築する木がバランスが取れていると当てにできるでしょうか。
;バランスの取れた木から始めたとしても、 adjoin-set で要素を追加すると、バランスの取れていない結果になってしまうかもしれません。
;新たに追加する要素の位置は、その要素と集合にすでに存在する項目の大小を比べた結果によるので、
;要素を “ランダムに” 追加すれば、平均的には木はバランスの取れたものになりやすくなります。しかし、このことは保証されていません。

;この問題を解決する方法のひとつとして、任意の木を同じ要素を持つバランスの取れた木に変換する演算を定義するというものがあります。
;こうすると、何回か adjoin-set 演算を行うたびにこの変換を実行して、集合をバランスの取れた状態にしておくことができます。
;この問題を解く方法はほかにもありますが、だいたいは検索や挿入がどちらも Θ(log n) ステップで行えるような
;新しいデータ構造を設計するということをしています。
