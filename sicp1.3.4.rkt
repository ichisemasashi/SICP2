; SICP 1.3.4 返り値としての手続き

;1.3.3 節の最後で説明した不動点の例
;√x は y → x/y 関数の不動点であるという観察結果からスタートして、
;不動点探索という形で平方根手続きの新しいバージョンを定式化しました。
;次に、平均緩和法を使って近似値が収束するようにしました。
;平均緩和法では、関数 f が与えられたとき、それに対応する別の関数を考えます。
;その関数は、x における値が x と f (x) の平均となるようなものです。
;平均緩和法の考え方は、次の手続きによって表現できます。
(define (average-damp f)
  (lambda (x) (average x (f x))))
;average-damp は、引数として手続き f を取り、(lambda で生成された) 手続きを返り値とする手続きです。
;例えば、average-damp を square 手続きに適用すると、
;x での値が x と x 2 の平均であるような手続きを返します。
;square-root 手続き
(load "sicp1.3.3.rkt")
(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y))) 1.0))
; この手法の三つの考え方を明確に示しています。
;不動点探索、平均緩和法、そして関数 y → x/y です。


; 1.1.7の平方根の手法の定式化
;(define (sqrt-iter guess x)
;  (if (good-enough? guess x)
;      guess
;      (sqrt-iter (improve guess x) x)))
;(define (improve guess x)
;  (average guess (/ x guess)))
;(define (average x y)
;  (/ (+ x y) 2))
;(define (good-enough? guess x)
;  (< (abs (- (square guess) x)) 0.001))
;(define (sqrt x)
;  (sqrt-iter 1.0 x))
;;;
;これらの手続きは同じプロセスを表現しているということに気をつけて、
;これらの抽象化を使って表現することでどれだけ考え方が明確になっているかを見てください。
;再利用の単純な例として、x の三乗根が y → x/y^2の不動点であり、
;そのため私たちの平方根の手続きはすぐに立方根を求めるものに拡張可能
(define (cube-root x)
  (fixed-point (average-damp (lambda (y) (/ x (square y)))) 1.0))

;;;;;;;;;;
; ニュートン法
; x → g(x) が微分可能な関数であるとき、方程式 g(x) = 0 の解は、以下に示す関数 x → f (x) の不動点となります。
; f(x) = x -  g(x)/Dg(x)
; ここで、Dg(x) は g の導関数を x で評価したものです。
; ニュートン法は、上で見た不動点探索法を利用して、関数 f の不動点を探すことによって方程式の解を近似するというものです。
; 多くの関数 g と、十分によい初期推測値 x に対して、ニュートン法はg(x) = 0 の解に急速に収束します。
;ニュートン法を手続きとして実装するには、まず微分という考え方を表現する必要があります。
;g が関数で dx が小さな値であるとき、g を微分した Dg は、任意の数値 x における値が 次のようになる関数です。
; Dg(x)= {g(x+dx) - g(x)}/dx
;このため、微分という考え方は次のような手続きとして表現できます。
(define dx 0.000001)
(define (deriv g)
  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))
;deriv は手続きを引数に取り手続きを返り値とする手続きです。
; 例: x 7→ x 3 を微分したものの x = 5 での値 (正確な値は 75 です)の近似値を求める
(define (cube x)
  (* x x x))
;> ((deriv cube) 5)
;75.00001501625775
;> 
; deriv の助けを借りると、ニュートン法は不動点探索プロセスとして表現できます。
;;;; x → g(x) が微分可能な関数であるとき、方程式 g(x) = 0 の解は、以下に示す関数 x → f (x) の不動点となります。
;;;; f(x) = x -  g(x)/Dg(x)
(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))
(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))
;x の平方根は、初期推測値 1 から始めて、
;y → y^2 − x 関数の零点をニュートン法によって求めることによって求められます。
(define (sqrt x)
  (newtons-method (lambda (y) (- (square y) x)) 1.0))

;;;;;;;;;
;; 抽象化とファーストクラス手続き
;ここまで、平方根計算をより一般的な手法の具体例として表現する二つの方法を見てきました。
;ひとつは不動点探索で、もうひとつはニュートン法です。
;どちらもある関数から始め、その関数を変形したものの不動点を求めます。
;この一般的な考え方自体、手続きとして表現できます。
(define (fixed-point-of-transform g transform guess)
  (fixed-point (transform g) guess))
;このとても一般的な手続きは、引数として手続き g(何らかの関数を計算する)、g を変形する手続き、初期推測値を取ります。
;返り値は変形された関数の不動点です。
;この抽象化によって、この節の最初の (y → x/y の平均緩和バージョンに対
;して不動点を求める) 平方根計算を、この一般的な方法の一例として書き直す
;ことができます。
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (/ x y)) average-damp 1.0))
;この節の二つ目の (y → y^2 − x のニュートン変形の不動点を求める) 平方根計算は、次のように表現できます。
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (- (square y) x)) newton-transform 1.0))
; 1.3 節は、複合手続きが非常に重要な抽象化メカニズムであるという観察結果から始めました。
;複合手続きは、私たちのプログラミング言語の中で、一般的な計算手法を明示的な要素として
;表現することを可能にするものだからです。ここでは、高階手続きを使うことによって、
;これらの一般的な手法を組み合わせてさらなる抽象化を生み出していけるということを見てきました。
; プログラマである私たちは、プログラムに潜んでいる抽象化を見つけ、それらの抽象化を使って
;プログラムを構築し、さらに強力な抽象化を生み出すためにそれらを一般化する機会を見逃さないようにしなければいけません。
; 高階手続きが重要なのは、これらの抽象化を明示的に私たちのプログラミング言語で表現する
;ことを可能にし、ほかの計算の要素と同じように扱えるようにしてくれるからです。
;一般的に、プログラミング言語は計算要素の操作方法に制約を課すものです。
;制約が最も少ない要素は、ファーストクラス (first-class) の地位を持つと言
;います。ファーストクラス要素の “権利と特権” のいくつかを次に示します。
;• 変数によって名前をつけることができる。
;• 手続きに引数として渡すことができる。
;• 手続きの返り値になることができる。
;• データ構造に組み込むことができる。
;Lisp は、ほかの一般的なプログラミング言語と違い、手続きに完全なファーストクラスの地位を与えています。
;このことは効率的な実装をするうえでの課題となりますが、そのおかげで非常に強い表現力を手にすることが可能です。

